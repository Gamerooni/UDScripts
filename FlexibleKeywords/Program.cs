using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins;
using Noggog;
using System.Data;

namespace FlexibleKeywords
{
    public class Program
    {
        public static Lazy<FKSettings> _settings = null!;
        public static FKSettings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                "Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "FlexibleKeywords.esp")
                .Run(args);
        }

        /// <inheritdoc cref="GetAllRulesForArmor(IArmorGetter, ILinkCache)" path="//param"/>
        /// <summary>
        /// Checks if <paramref name="matcher"/>'s rules apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="matcher">The rule as defined in the settings</param>
        /// <returns><c>true</c> if we have a match, <c>false</c> otherwise</returns>
        public static bool IsArmorMatchedBySetting(IArmorGetter armor, ArmorMatcher matcher, ILinkCache linkCache)
        {
            var matcherOperations = new ArmorMatcherOperations(matcher, linkCache);
            return matcherOperations.MatchArmor(armor);
        }

        public static HashSet<IFormLinkGetter<IKeywordGetter>> GetValidKeywordsToRemove(IArmorGetter armor, 
            IEnumerable<IFormLinkGetter<IKeywordGetter>> keywords)
        {
            var result = new HashSet<IFormLinkGetter<IKeywordGetter>>();
            var armorKeywords = armor.Keywords;
            if (armorKeywords != null && armorKeywords.Any() && keywords.Any())
            {
                result = armorKeywords.Intersect(keywords).ToHashSet();
            }
            return result;
        }

        /// <summary>
        /// Applies <paramref name="rule"/> to <paramref name="armor"/> by first adding then removing Keywords, as defined in the <paramref name="rule"/>.
        /// </summary>
        /// <param name="armor">Mutable Armor record to apply <paramref name="rule"/> to</param>
        /// <param name="rule"></param>
        /// <returns><c>true</c> if <paramref name="armor"/> has been modified, <c>false</c> otherwise.</returns>
        public static bool ApplyRuleToArmor(IArmor armor, KeywordRules rule)
        {
            if (armor.Keywords == null)
            {
                armor.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>();
            }
            var originalKeywords = new HashSet<IFormLinkGetter<IKeywordGetter>>(armor.Keywords);
            armor.Keywords = armor.Keywords.Union(rule.KeywordsToAdd).ToExtendedList();
            armor.Keywords.RemoveAll(keyword => rule.KeywordsToRemove.Contains(keyword));
            return !(originalKeywords.IsProperSubsetOf(armor.Keywords) &&
                originalKeywords.IsProperSupersetOf(armor.Keywords));
        }

        /// <inheritdoc cref="ApplyRuleToArmor(IArmor, KeywordRules)" path="//returns|//param"/>
        /// <summary>
        /// Applies all rules in <paramref name="rules"/> to <paramref name="armor"/> in the given order.
        /// </summary>
        /// <param name="rules">The rules in question</param>
        public static bool ApplyRulesToArmor(IArmor armor, IEnumerable<KeyValuePair<int, KeywordRules>> rules)
        {
            var result = false;
            foreach (var rule in rules)
            {
                if (ApplyRuleToArmor(armor, rule.Value)) result = true;
            }
            return result;
        }

        /// <summary>
        /// Gets all rules which apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="armor">The Armor record to check</param>
        /// <param name="linkCache">Link cache to retrieve Keywords with</param>
        /// <returns>All rules which apply to <paramref name="armor"/>, ordered in ascending order by <see cref="KeywordRules.Priority"/></returns>
        public static SortedList<int, KeywordRules> GetAllRulesForArmor(IArmorGetter armor, ILinkCache linkCache)
        {
            var rules = new SortedList<int, KeywordRules>();
            foreach (var rule in Settings.Rules)
            {
                if (IsArmorMatchedBySetting(armor, rule.MatchingRules, linkCache)) {
                    rules[rule.Priority] = rule;
                }
            }
            return rules;
        }

        public static void ProcessArmor(IArmor armor, ILinkCache linkCache)
        {
            ApplyRulesToArmor(armor, GetAllRulesForArmor(armor, linkCache));
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var shortenedLoadOrder = Settings.ModsToPatch.Any() ? state.LoadOrder.PriorityOrder
                .Where(mod => Settings.ModsToPatch.Contains(mod.ModKey)) : state.LoadOrder.PriorityOrder;

            var linkCache = state.LoadOrder.ToImmutableLinkCache();

            foreach(var armor in shortenedLoadOrder.Armor().WinningOverrides())
            {
                var rules = GetAllRulesForArmor(armor, linkCache);
                var newArmor = armor.DeepCopy();
                if (ApplyRulesToArmor(newArmor, rules))
                {
                    state.PatchMod.Armors.Add(newArmor);
                }
            }
        }
    }
}
