using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins;
using Noggog;
using System.Data;

namespace FlexibleKeywords
{
    public class Program
    {
        public static Lazy<FKSettings> _settings = null!;
        public static FKSettings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                "Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "FlexibleKeywords.esp")
                .Run(args);
        }

        public static bool IsArmorMatchedBySetting(IArmorGetter armor, ArmorMatcher matcher, ILinkCache linkCache)
        {
            var matcherOperations = new ArmorMatcherOperations(matcher, linkCache);
            return matcherOperations.MatchArmor(armor);
        }

        public static HashSet<IFormLinkGetter<IKeywordGetter>> GetValidKeywordsToRemove(IArmorGetter armor, 
            IEnumerable<IFormLinkGetter<IKeywordGetter>> keywords)
        {
            var result = new HashSet<IFormLinkGetter<IKeywordGetter>>();
            var armorKeywords = armor.Keywords;
            if (armorKeywords != null && armorKeywords.Any() && keywords.Any())
            {
                result = armorKeywords.Intersect(keywords).ToHashSet();
            }
            return result;
        }

        public static bool ApplyRuleToArmor(IArmor armor, KeywordRules rule)
        {
            if (armor.Keywords == null)
            {
                armor.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>();
            }
            var originalKeywords = new HashSet<IFormLinkGetter<IKeywordGetter>>(armor.Keywords);
            armor.Keywords = armor.Keywords.Union(rule.KeywordsToAdd).ToExtendedList();
            armor.Keywords.RemoveAll(keyword => rule.KeywordsToRemove.Contains(keyword));
            return !(originalKeywords.IsProperSubsetOf(armor.Keywords) &&
                originalKeywords.IsProperSupersetOf(armor.Keywords));
        }

        public static bool ApplyRulesToArmor(IArmor armor, IEnumerable<KeyValuePair<int, KeywordRules>> rules)
        {
            var result = false;
            foreach (var rule in rules)
            {
                if (ApplyRuleToArmor(armor, rule.Value)) result = true;
            }
            return result;
        }

        public static SortedList<int, KeywordRules> GetAllRulesForArmor(IArmorGetter armor, ILinkCache linkCache)
        {
            var rules = new SortedList<int, KeywordRules>();
            foreach (var rule in Settings.Rules)
            {
                if (IsArmorMatchedBySetting(armor, rule.MatchingRules, linkCache)) {
                    rules[rule.Priority] = rule;
                }
            }
            return rules;
        }

        public static void ProcessArmor(IArmor armor, ILinkCache linkCache)
        {
            ApplyRulesToArmor(armor, GetAllRulesForArmor(armor, linkCache));
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var shortenedLoadOrder = state.LoadOrder.PriorityOrder
                .Where(mod => Settings.ModsToPatch.Contains(mod.ModKey));

            var linkCache = state.LoadOrder.ToImmutableLinkCache();

            foreach(var armor in shortenedLoadOrder.Armor().WinningOverrides())
            {
                var rules = GetAllRulesForArmor(armor, linkCache);
                var newArmor = armor.DeepCopy();
                if (ApplyRulesToArmor(newArmor, rules))
                {
                    state.PatchMod.Armors.Add(newArmor);
                }
            }
        }
    }
}
